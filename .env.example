# AI Higress Gateway 环境变量示例
#
# 使用方式：
# 1. 复制本文件为 .env
# 2. 按需修改下方密码/密钥/回调地址
# 3. 运行开发镜像（推荐新手）：
#    IMAGE_TAG=latest docker compose -f docker-compose.develop.yml --env-file .env up -d
# 4. 生产部署：
#    IMAGE_TAG=latest docker compose -f docker-compose-deploy.yml --env-file .env up -d
#
# 说明：
# - 本示例默认面向 Docker 镜像/Compose 场景，因此 DATABASE_URL / REDIS_URL 使用容器内服务名
#   （postgres/redis），不要写本机回环地址。
# - 如果你选择“本地运行后端 + Docker 起数据库/Redis”，请参考各段落中的本机地址示例改写 URL。

# 运行环境与日志
APP_ENV=development

# JWT 密钥路径（Docker 镜像模式下，路径为容器内路径）
JWT_PRIVATE_KEY_PATH=/app/security/private.pem
JWT_PUBLIC_KEY_PATH=/app/security/public.pem


# CORS 配置（多个来源用英文逗号分隔）
# 前端在容器外访问时通常为 http(s)://你的域名 或 http://你的IP:3000
# 本地前端默认可用：http://127.0.0.1:3000
CORS_ALLOW_ORIGINS=http://your-frontend-domain-or-ip:3000
CORS_ALLOW_CREDENTIALS=true
CORS_ALLOW_METHODS=*
CORS_ALLOW_HEADERS=*

# 初始管理员（可自定义，首次启动自动创建）
DEFAULT_ADMIN_USERNAME=admin
DEFAULT_ADMIN_EMAIL=admin@example.com

# PostgreSQL 配置
POSTGRES_USER=apiproxy
# 必填：请设置强密码（Docker Compose 配置要求不能为空）
POSTGRES_PASSWORD=
POSTGRES_DB=apiproxy

# Docker 镜像模式（推荐）：后端容器通过 service 名访问数据库
DATABASE_URL=postgresql+psycopg://${POSTGRES_USER}:${POSTGRES_PASSWORD}@postgres:5432/${POSTGRES_DB}  # pragma: allowlist secret
# 本地运行后端（非容器）时可改为（compose 暴露端口默认 15432）：
# DATABASE_URL=postgresql+psycopg://${POSTGRES_USER}:${POSTGRES_PASSWORD}@127.0.0.1:15432/${POSTGRES_DB}  # pragma: allowlist secret

# Redis 配置
# 必填：请设置强密码（Docker Compose 配置要求不能为空）
REDIS_PASSWORD=
# Docker 镜像模式（推荐）
REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379/0
# 本地运行后端（非容器）时可改为（compose 暴露端口默认 16379）：
# REDIS_URL=redis://:${REDIS_PASSWORD}@127.0.0.1:16379/0

# 限流默认值（可被 provider preset / API Key 覆盖）
RATE_LIMIT_EXTERNAL_RPM=60
RATE_LIMIT_INTERNAL_RPM=600
RATE_LIMIT_EXTERNAL_TPM=100000
RATE_LIMIT_INTERNAL_TPM=1000000
RATE_LIMIT_WINDOW_SECONDS=60

# 可观察性与风控
# 自定义 trace id 头（可保持默认）
TRACE_ID_HEADER=X-Trace-Id
# 网关入口并发上限与排队超时
GATEWAY_MAX_CONCURRENCY=200
GATEWAY_QUEUE_TIMEOUT=0.25
# 请求/响应大小限制（字节）
MAX_REQUEST_BYTES=524288
MAX_RESPONSE_BYTES=2097152
# 上游域名白名单（逗号分隔），默认仅本地调试域名
OUTBOUND_WHITELIST=localhost,127.0.0.1

# 上游代理池（可选，兼容 legacy Redis 结构）
UPSTREAM_PROXY_ENABLED=false
UPSTREAM_PROXY_FAILURE_COOLDOWN_SECONDS=120
UPSTREAM_PROXY_MAX_RETRIES=1

# Qdrant（向量数据库，可选；用于知识库/语义缓存等）
# - 默认关闭：仅当 QDRANT_ENABLED=true 且 QDRANT_URL 非空时后端才会启用 Qdrant 客户端
# - Docker Compose（本仓库 docker-compose.*）内建议用 service 名：http://qdrant:6333
QDRANT_ENABLED=false
QDRANT_URL=http://qdrant:6333
# 如果你的 Qdrant 开启了 API Key 鉴权，请填写；否则留空
QDRANT_API_KEY=
# Qdrant 请求超时（秒）
QDRANT_TIMEOUT_SECONDS=10
# Collection 名（按用途拆分，避免向量库污染）
QDRANT_KB_SYSTEM_COLLECTION=kb_system
# user 维度 collection 拆分策略：
# - shared（默认）：单一大集合（推荐 MVP），用 payload.owner_user_id / payload.project_id 逻辑隔离。
# - per_user：每用户一个 collection，物理隔离，删除用户数据可直接 drop collection。
# - sharded_by_model：按 embedding 模型分片（推荐 ToC 大规模用户），用 payload.owner_user_id 过滤隔离。
QDRANT_KB_USER_COLLECTION_STRATEGY=shared
# shared 策略下使用的 user 大集合名（建议带版本号，便于未来迁移）
QDRANT_KB_USER_SHARED_COLLECTION=kb_shared_v1
# 当策略为 sharded_by_model 时，分片数量（建议 8/16/32；越大 collection 越多，但单 collection 压力越小）
QDRANT_KB_USER_COLLECTION_SHARDS=16
# 注意：QDRANT_KB_USER_COLLECTION 作为 “collection 前缀” 使用：
# - per_user：<QDRANT_KB_USER_COLLECTION>_<user_id_hex>
# - sharded_by_model：<QDRANT_KB_USER_COLLECTION>_<model_hash>_shard_<idx>
QDRANT_KB_USER_COLLECTION=kb_user

# 统一 Embedding 模型（推荐 MVP）：全平台统一使用一个 embedding 逻辑模型，用户/项目不可改。
# 当该值非空时，将忽略项目级的 kb_embedding_logical_model 配置。
# 注意：当 QDRANT_KB_USER_COLLECTION_STRATEGY=shared 时，该值必须配置，否则会跳过记忆写入/检索。
KB_GLOBAL_EMBEDDING_LOGICAL_MODEL=

# Celery 配置（默认复用同一 Redis）
CELERY_BROKER_URL=${REDIS_URL}
CELERY_RESULT_BACKEND=${REDIS_URL}

# 积分/计费
# 是否在网关层强制校验用户积分余额（不足时返回 402）
ENABLE_CREDIT_CHECK=false
# 流式请求是否在开始前做预估扣费（默认关闭）
ENABLE_STREAMING_PRECHARGE=false
# 流式请求在无法获取 usage 时用于预估扣费的最小 token 数
STREAMING_MIN_TOKENS=500
# 会话模式下构建上游 messages 时最多携带的历史消息条数（不含 system；不含本次新 user 消息）。0 表示不限制。
CHAT_CONTEXT_MAX_MESSAGES=50

# 对象存储（建议使用两桶命名：ai-gateway-public / ai-gateway-private）
# - ai-gateway-public：公共读（开启），用于头像/系统图标等前端直链资源
# - ai-gateway-private：私有（关闭），用于需要受控访问的资源（例如生成图片短链、RAG 文档等）
OSS_PROVIDER=s3
OSS_ENDPOINT=
OSS_REGION=
OSS_ACCESS_KEY_ID=
OSS_ACCESS_KEY_SECRET=
OSS_PUBLIC_BUCKET=ai-gateway-public
OSS_PRIVATE_BUCKET=ai-gateway-private
OSS_PUBLIC_BASE_URL=

# 用户头像存储（可直接复用上面的 OSS_*；也支持用 AVATAR_OSS_* 覆盖）
# 说明：
# - AVATAR_STORAGE_MODE=auto（默认）：非 production 写本地；production 优先写 OSS/S3（未配置则回退本地）；
# - AVATAR_STORAGE_MODE=local：强制写本地（AVATAR_LOCAL_DIR）；
# - AVATAR_STORAGE_MODE=oss：强制写 OSS/S3（需要 AVATAR_OSS_* + AVATAR_OSS_BASE_URL）；
# - AVATAR_OSS_BASE_URL：前端直链访问的基础 URL（建议绑定 CDN 域名或公开桶域名；未填时可用 OSS_PUBLIC_BASE_URL 兜底）。
AVATAR_STORAGE_MODE=auto         # 可选：auto（默认）、local、oss
AVATAR_LOCAL_DIR=backend/media/avatars
AVATAR_LOCAL_BASE_URL=/media/avatars
AVATAR_OSS_BASE_URL=
AVATAR_STORAGE_PROVIDER=aliyun_oss # 可选：aliyun_oss（默认），s3（AWS/MinIO/Cloudflare R2 兼容接口）
AVATAR_OSS_ENDPOINT=
AVATAR_OSS_REGION=
AVATAR_OSS_BUCKET=
AVATAR_OSS_ACCESS_KEY_ID=
AVATAR_OSS_ACCESS_KEY_SECRET=

# 文生图图片存储（支持阿里 OSS / 兼容 S3 的 Cloudflare R2、MinIO 等，可选；默认优先使用 OSS_PRIVATE_BUCKET）
# 说明：
# - IMAGE_STORAGE_MODE=auto（默认）：非 production 环境写入本地磁盘，production 环境写入对象存储；
# - IMAGE_STORAGE_MODE=local：强制写入本地磁盘（便于开发调试，图片保存在 media 目录下）；
# - IMAGE_STORAGE_MODE=oss：强制写入对象存储（Aliyun OSS / S3/R2/MinIO 兼容）；
# - response_format=url 会返回网关短链（/media/images/...）；local 模式短链直接返回图片内容，oss 模式短链 302 到对象存储的预签名 URL；
# - 短链经网关校验后：local 模式直接返回图片内容；oss 模式 302 到存储的预签名 URL（TTL 由 IMAGE_SIGNED_URL_TTL_SECONDS 控制）；
# - 建议 Bucket 设为私有读；若用 Cloudflare R2/MinIO 等，请切换 provider=s3 并填写 region/endpoint。
IMAGE_STORAGE_MODE=auto          # 可选：auto（默认）、local、oss
IMAGE_LOCAL_DIR=backend/media/images
IMAGE_STORAGE_PROVIDER=aliyun_oss # 可选：aliyun_oss（默认），s3（AWS/MinIO/Cloudflare R2 兼容接口）
IMAGE_OSS_ENDPOINT=              # 例：https://oss-cn-hangzhou.aliyuncs.com 或 https://<account>.r2.cloudflarestorage.com
IMAGE_OSS_REGION=                # S3/R2 需要（如 auto/us-east-1）；阿里 OSS 可留空
IMAGE_OSS_BUCKET=
IMAGE_OSS_ACCESS_KEY_ID=
IMAGE_OSS_ACCESS_KEY_SECRET=
IMAGE_OSS_PREFIX=generated-images
IMAGE_SIGNED_URL_TTL_SECONDS=3600

# 业务资产（短链/受控访问）存储
# - 统一走私有桶 + 网关短链签名（/media/assets/...）
# - auto：有 OSS 配置则走 OSS；否则落本地 backend/media/assets
# - 本地模式仅用于开发，生产请配置 OSS 以避免网关直传大文件
ASSET_STORAGE_MODE=auto
ASSET_LOCAL_DIR=backend/media/assets
ASSET_OSS_PREFIX=assets
ASSET_SIGNED_URL_TTL_SECONDS=3600

# 安全中间件开关：true 强制开启，false 强制关闭
# 默认行为：APP_ENV=production 时开启；非生产环境关闭
ENABLE_SECURITY_MIDDLEWARE=true
# ENABLE_SECURITY_MIDDLEWARE=false

# API 文档路由开关：true 强制开启，false 强制关闭
# 默认行为：APP_ENV=production 时关闭 /docs、/redoc、/openapi.json；非生产环境开启
ENABLE_API_DOCS=

# 应用密钥（用于 JWT/HMAC/加密等敏感标识）
# 请使用系统 API POST /system/secret-key/generate 生成随机值并替换
SECRET_KEY=

# Bridge / MCP Tunnel Gateway（可选）
# 后端 -> Gateway 内网调用地址（Docker Compose 下建议使用服务名）
BRIDGE_GATEWAY_URL=http://bridge_gateway:8088
# 保护 Gateway 内网接口 /internal/bridge/* 的共享 Token（强烈建议设置；否则对公网暴露 8088 时会有风险）
BRIDGE_GATEWAY_INTERNAL_TOKEN=

# LinuxDo OAuth2（可选，启用后可使用 LinuxDo 登录）
LINUXDO_OAUTH_ENABLED=false
LINUXDO_CLIENT_ID=
LINUXDO_CLIENT_SECRET=
# 回调地址必须是你实际可访问的域名（不要使用本机回环地址），例如：https://ai.example.com/callback
LINUXDO_REDIRECT_URI=https://your-domain.com/callback

# Provider 健康检查与路由过滤
# 是否启用 Provider 健康状态检查和路由过滤（关闭后将忽略 Provider 状态和最低分数过滤）
ENABLE_PROVIDER_HEALTH_CHECK=true

# Provider 实时故障标记（用于快速跳过故障 Provider）
# 故障冷却期（秒）：在此期间内失败次数超过阈值的 Provider 将被跳过
PROVIDER_FAILURE_COOLDOWN_SECONDS=60
# 故障阈值：在冷却期内失败次数超过此值将被跳过
PROVIDER_FAILURE_THRESHOLD=3

# 上游请求代理池
# 已改为“后台管理式代理池”（DB 配置 + Celery 测活 + Redis 可用集合），不再通过环境变量配置代理列表。
# 仍可通过环境变量控制“同一次上游请求内，代理连接失败时的换代理重试次数”（0 表示不重试）。
UPSTREAM_PROXY_MAX_RETRIES=1

LOG_LEVEL=INFO
# LOG_TIMEZONE=Asia/Shanghai
# 日志输出目录（相对路径以 backend 项目根目录为基准）
LOG_DIR=logs
# 保留最近 N 天的日志目录；0 表示不清理
LOG_BACKUP_DAYS=7
# 是否按业务拆分日志文件（拆分后目录结构示例：logs/2025-12-12/chat.log）
LOG_SPLIT_BY_BUSINESS=true

# Next.js 环境变量示例

# API 地址（用于前端访问后端 API，也用于 CLI 配置脚本生成）
NEXT_PUBLIC_API_BASE_URL=http://localhost:8000

# 后端 API 基础 URL（用于 CLI 配置脚本中的 api_url 字段）
# 生产环境请设置为实际的域名，例如: https://your-domain.com
# 这个 URL 会被写入到 Claude Code CLI 和 Codex CLI 的配置文件中
API_BASE_URL=http://localhost:8000

# 分析开关
ANALYZE=false

# 类型检查开关
SKIP_TYPE_CHECK=false
